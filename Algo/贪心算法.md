# 贪心算法

## 455.分发饼干

> #### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)
>
> 难度简单161
>
> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
> **注意：**
>
> 你可以假设胃口值为正。
> 一个小朋友最多只能拥有一块饼干。
>
> **示例 1:**
>
> ```
> 输入: [1,2,3], [1,1]
>
> 输出: 1
>
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```

### 贪心

```java
/*
    1.给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。
    2.因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。
    */
    public int findContentChildren(int[] g, int[] s) {
        if(g == null || s == null)  return -1;
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0, j = 0;
        while(i < g.length && j < s.length){
            if(g[i]<=s[j]){
                i++;//计数多少可以满足多少孩子
            }
            j++;
        }
        return i;
    }
```



## 122.买卖股票的最佳时机 II

> #### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
>
> 难度简单692
>
> 给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>  
>
> **示例 1:**
>
> ```
> 输入: [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
> ```

### 贪心

```java
	//time O(n)
    //因为要获取最大利润 只有当后一天的价格大于前一天价格，我们才去购买。
    public int maxProfit(int[] prices) {
        int maxProfit = 0;
        for(int i=0;i<prices.length-1;i++){
            if(prices[i+1] > prices[i]){
                maxProfit+=prices[i+1]-prices[i];
            }
        }
        return maxProfit;
    }
```

## 55.跳跃游戏

> #### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
>
> 难度中等647
>
> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个位置。
>
> **示例 1:**
>
> ```
> 输入: [2,3,1,1,4]
> 输出: true
> 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
>
> ```
>
> **示例 2:**
>
> ```
> 输入: [3,2,1,0,4]
> 输出: false
> 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
> ```

### 贪心

```java
	// 贪心算法  从后往前推  
    // nums[i] + i 表示从当前位置i加上 可以跳跃的最大值 
    // time : O(n)
    public boolean canJump(int[] nums) {
        if(nums == null)  return false;
        int pos = nums.length-1;
        for(int i=nums.length-1;i>=0;i--){
            if(nums[i]+i >= pos){
                pos = i;
            }
        }
        return pos == 0;
    }
```

## 45.跳跃游戏 || 

> #### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)
>
> 难度困难547
>
> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> **示例:**
>
> ```
> 输入: [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```

### 从后往前查找-贪心

```java
/**反向查找出发位置
      跳跃游戏 可以通过贪心算法来完成，可以从前往后 或者 从后往前，通过获取局部最优解
      来解决全局最优解。
      从nums.length-1位置 查找之前的一个元素是否能到达，如果可以，遍历数组 从0开始到这个位置。
      找出最大值，依序查找，每次选取最大的步数，也就是局部最优解，而最优解，就可以决定全局是一个最优解
      time : O(N^2) 当数组中都是相同的数字，需要查找N^2次
      space : O(1)
      break 跳出循环  continue 结束本次循环 继续下次循环
    */
    public int jump(int[] nums) {
      if(nums == null || nums.length == 0){
          return -1;
      }
      int steps = 0;//需要跳跃的次数
      int position = nums.length-1;
      while(position > 0){
        for(int i=0;i<position;i++){
          if(nums[i]+i>=position){//可以到达
            position = i;
            steps++;
            break;
          }
        }
      }
      return steps;
    }
```

### 从前往后查找-贪心

```java
/*
        刚才从后往前推 对于特定的相同的数组，需要遍历O(N^2)次 时间复杂度比较高。
        我们换一个思路 从前往后推。[2,3,1,1,4]
        steps>记录次数  end>记录当前步长可以走的界限。
        比如 从0 位置出发，end = 2 在0位置2步内找到最大值。最大为3，调到3上
        在end=3位置查找最大值 发现可以跳出。因此结束。
        ps：此处 我们没有跳跃到数组的末尾位置，因此当可以跳出的时候只会大于或等于。
        time : O(n) space :O(1)
    */
    public int jump(int[] nums) {
        if(nums == null || nums.length == 0){
            return -1;
        }
        int steps = 0;
        int end = 0;//当前可以跳跃的最大步长
        int maxLength = 0;
        for(int i= 0;i<nums.length-1;i++){
            maxLength = Math.max(maxLength,nums[i]+i);
            if(end == i){ //end == i 其实比较的就是在最大步长内 是否会有一个更大的步长 
                end = maxLength;
                steps++;
            }
        }
        return steps;
    }
```



## 860.柠檬水找零

> #### [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)
>
> 难度简单106
>
> 在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。
>
> 顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。
>
> 每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。
>
> 注意，一开始你手头没有任何零钱。
>
> 如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。
>
> **示例 1：**
>
> ```
> 输入：[5,5,5,10,20]
> 输出：true
> 解释：
> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
> 由于所有客户都得到了正确的找零，所以我们输出 true。
> ```

### 贪心

```java
/*
     问题细化 其实只需要考虑三种情况
     1.如果顾客给了5元  five++;
     2.如果顾客给了10元 five-- ten++;
     3.如果顾客给了20元 先用最大的钱 ten-- five-- or five-=3; 而20元的钱 我们是不能用于找零的 这里可以忽略
     
     time :O(n)
    */
    public boolean lemonadeChange(int[] bills) {
        if(bills == null || bills.length == 0){
            return false;
        }   
        int five = 0, ten = 0;//5元 10元的个数
        for(int bill : bills){
            if(bill == 5)   five++;
            else if(bill == 10){    five--; ten++;
            }else if(ten > 0){      ten--; five--;
            }else  five-=3;
            if(five<0){
                return false;
            }
        }
        return true;
    }
```

## 874.模拟行走机器人

> #### [874. 模拟行走机器人](https://leetcode-cn.com/problems/walking-robot-simulation/)
>
> 难度简单86
>
> 机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：
>
> - `-2`：向左转 90 度
> - `-1`：向右转 90 度
> - `1 <= x <= 9`：向前移动 `x` 个单位长度
>
> 在网格上有一些格子被视为障碍物。
>
> 第 `i` 个障碍物位于网格点  `(obstacles[i][0], obstacles[i][1])`
>
> 机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。
>
> 返回从原点到机器人的最大欧式距离的**平方**。
>
>  
>
> **示例 1：**
>
> ```
> 输入: commands = [4,-1,3], obstacles = []
> 输出: 25
> 解释: 机器人将会到达 (3, 4)
>
> ```
>
> **示例 2：**
>
> ```
> 输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
> 输出: 65
> 解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处
> ```











