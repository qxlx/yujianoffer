# 位运算

## 191.位1的个数

> #### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)
>
> 难度简单162
>
> 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。
>
>  
>
> **示例 1：**
>
> ```
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
>
> ```
>
> **示例 2：**
>
> ```
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
>
> ```
>
> **示例 3：**
>
> ```
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
> ```

### 1.右移

```java
    //右移
    public int hammingWeight(int n) {
        int count = 0;
        while(n!=0){
            count += n & 1;
            n >>>= 1;
        }
        return count;
    }
```

### 2.巧用n&(n-1)

```java
	//巧用n&(n-1)
    public int hammingWeight(int n) {
        int count = 0;
        while(n!=0){
            count++;
            n = n &(n-1);
        }
        return count;
    }
```

## 231.2的幂

> #### [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)
>
> 难度简单188
>
> 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
>
> **示例 1:**
>
> ```
> 输入: 1
> 输出: true
> 解释: 20 = 1
> ```

```java
	//2的幂可以理解为 二进制中仅有一个数字为1 
    public boolean isPowerOfTwo(int n) {
        if(n <= 0)  return false;
        return (n > 0) && ((n & (n-1)) == 0); 
    }
```

## 190.颠倒二进制位

> #### [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)
>
> 难度简单161
>
> 颠倒给定的 32 位无符号整数的二进制位。
>
>  
>
> **示例 1：**
>
> ```
> 输入: 00000010100101000001111010011100
> 输出: 00111001011110000010100101000000
> 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
>       因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
> ```



```java
public int reverseBits(int n) {
        int ans = 0;
        for(int i=0;i<32;i++){
            ans = (ans<<1) + (n & 1);
            n >>= 1;
        }
        return ans >>> 0;
    }
```

